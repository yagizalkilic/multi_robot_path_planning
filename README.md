# Multi-Robot Path Planning on Predefined Routes

## Problem Definition

A set of n robots travel along predefined paths. The purpose of this project is to coordinate these robots without any alteration to their paths, only changes that can be made are to robots' velocities and durations of velocity application. The project utilizes coordination graphs and RRT/RTT*/RRT*-connect algorithms to solve the problem. More information regarding the methodology is explained later.

## Future Improvements

- Velocity profile generation under acceleration constraints needs to be improved on as robots exceed acceleration limits at some cases.
- Another simulation can be used to further research solution accuracy. (Turtlesim does not let the user to increase the map size.)
- Connected RRT* algorithm can be improved on by smoothing the found path.

## Program Information

### Turtlesim Implementation

Turtlesim package is used to simulate the problem and test the solution. The main purpose of this implementation is to apply the schedule that was generated by the connected RRT* to a representation of the physical world.

- The multi_path_scheduling package contains 7 executables. (In order to execute the program, https://root.cern/ should be installed.)

    - turtle_restrained_publisher:generates turtles from turtlesim library, generates or receives paths for the turtles, and calculates accleration limited schedules for the paths. (turtles can only move on linear paths)
      
    - turtle_restrained_subscriber: makes the turtles follow their paths in the given schedule.
      
    - turtle_unrestrained_publisher:  generates turtles from turtlesim library, generates paths for the turtles, and calculates schedules for the paths. (acceleration limits are not simulated)

    - turtle_unrestrained_subscriber: makes the turtles follow their paths in the given schedule.

    - algorithm_test: used to test algorithms that are used.

    - turtle_teleporter_publisher:  generates turtles from turtlesim library, generates paths for the turtles, and calculates schedules for the paths. (teleporter executables are obsolete, but they can be used for RRT debugging purposes as it can be hard to pinpoint the problems with planner involvement.)

    - turtle_teleporter_subscriber: makes the turtles follow their paths in the given schedule, does this by teleporting the turtles using turtlesim teleport service.

- Steps to run the turtle simulation:
    - If you want to execute turtle scheduling with acceleration limits, first change the directory to the grid_test file in turtle_restrained_publisher.cpp to your computer's directory. Then, in a new terminal run: roslaunch path_scheduling_turtle_sim_tests path_planning_turtle_sim.launch
    - If you want to execute turtle scheduling with velocities, in a new terminal run: roslaunch path_scheduling_turtle_sim_tests path_planning_turtle_sim.launch
    - If you want to execute turtle scheduling by teleporting, in a new terminal run: roslaunch path_scheduling_turtle_sim_tests path_planning_turtle_teleporter_sim.launch
      
- Alternatively:
    - In a new terminal run: roscore
    - In a new terminal run: rosrun turtlesim turtlesim_node 
    - In a new terminal (source your workspace if not sourced) run: rosrun multi_path_scheduling turtle_restrained_publisher
    - In a new terminal (source your workspace if not sourced) run: rosrun multi_path_scheduling turtle_restrained_subscriber
    - Note: If you wish to run turtle teleporter use turtle_teleporter_publisher and turtle_teleporter_subscriber, or if you want to run unrestrained schedules use turtle_unrestrained_publisher and turtle_unrestrained_subscriber instead.
- If you wish to only run the RRT, RRT* and see the outputs:

    - In a new terminal (source your workspace if not sourced) run: rosrun multi_robot_path_scheduling algorithm_test
 
Turtle restrained simulations output:

[acceleration_restrained.webm](https://github.com/yagizalkilic/multi_robot_path_planning/assets/43394146/18d6e840-3fe0-43bf-8b50-4be195227a67)

Turtle unrestrained simulations output:

[velocity_schedules.webm](https://github.com/yagizalkilic/multi_robot_path_planning/assets/43394146/2fa8c5a9-0194-4bc6-ad7d-8348aee34e61)

Turtle teleporter simulations output:

[turtle_teleporter.webm](https://github.com/yagizalkilic/multi_robot_path_planning/assets/43394146/dc184f09-d157-48f6-99e0-8e0fb9d906ee)

Algorithm test outputs:

<img src="https://github.com/yagizalkilic/multi_robot_path_planning/assets/43394146/d3c3a927-b917-4e97-a470-5a498c981845" width="380"/>
<img src="https://github.com/yagizalkilic/multi_robot_path_planning/assets/43394146/019e803b-5189-4896-a160-2294538a6cae" width="380"/>
<p align="center">
    <img src="https://github.com/yagizalkilic/multi_robot_path_planning/assets/43394146/80b6c958-2956-4261-a044-5fd49ead435f" width="300"/>
</p>


### Simple Algorithm Tests in Python

The initial testing of the methods were done in python. These scripts can be used to test the core methods.

- py_tests file contains scripts for the initial testing of the general methods:
  - simple_coordination_graph.py: simulates coordination graphs for 2 robots along a specified path.
      Outputs:
    <img src="https://github.com/yagizalkilic/multi_robot_path_planning/assets/43394146/32ecfde7-d249-4c2c-9329-0e36902e4e85" width="380"/>
    <img src="https://github.com/yagizalkilic/multi_robot_path_planning/assets/43394146/630dc372-e5c8-47d7-8627-eb7157506ccf" width="380"/>
  - 3D_coordination_euclidian.py: coordinates 3 robots on specified paths, visualizes the RRT algorithm. Uses euclidian distance to calculate proximity to collusion zones. Outputs are similar to 3D_coordination_grid.py.
  - 3D_coordination_grid.py: coordinates 3 robots on specified paths, visualizes the RRT algorithm. Puts paths and collusions on a grid, is more efficient. Outputs:
    
    <img src="https://github.com/yagizalkilic/multi_robot_path_planning/assets/43394146/060c5317-dfb6-4dcf-afaf-83501409e57d" width="380"/>

    <img src="https://github.com/yagizalkilic/multi_robot_path_planning/assets/43394146/0a592802-b273-4412-97d8-7976b113698f" width="380"/>

  - n_robot_coordination.py: calculates coordination graps for n robots. Cannot visualize in 3-D. Outputs:

     <img src="https://github.com/yagizalkilic/multi_robot_path_planning/assets/43394146/96871533-5ca6-4a51-8b97-a4036a910dc2" width="380"/>

     <img src="https://github.com/yagizalkilic/multi_robot_path_planning/assets/43394146/89da3c48-266d-4b97-a07f-436198a9f8bf" width="380"/>

## Methodology

### Definitions

A set of robots that are instructed to move along specified paths. The paths of the robots are subject to change in the event of an interruption during their movement. A robot *N* is defined in the 2-D configuration space C such that:

- Every robot follows a path _π_<sub>_n_</sub>. 

- A path is a sequence of adjacent segments and each segment s<sub>i</sub> ∈ [0, _l_(π<sub>i</sub> )], where _l_(π<sub>i</sub> ) is the total length of the path.

- Finally, the space occupied by a robot in configuration x<sub>i</sub> is represented as _A_(x<sub>i</sub> ).

## Coordination Diagram

Coordination diagrams represent all possible configurations and collusion regions along a robots path. Finding an obstacle free map from (0,0) to (1,1) in a coordination diagram provides a solution to the coordination problem, therefore they are commonly used in path coordination tasks. They were first introduced in [1].

### Constructing the Diagram: Collusion Zones

In order to construct the diagram, collusion zones can be defined as in [2]:

```math
X_{ij}^{coll} \ =\ \{\ ( s_{1} \ ,...,\ s_{N}\} \ \in \ S\ |\ A( \pi _{i}( s_{i})) \ \cap \ A( \pi _{j}( s_{j})) \ \neq \ \emptyset \ \}
```

#### A Simpler Approach

If the robots assumed to be circular in shape and equal in size, the formulation above can be simplified to as in [3]:

```math
X_{ij}^{coll} \ =\ \{\ ( s_{1} \ ,...,\ s_{N}\} \ \in \ S\ |\ ||\ \pi _{i}( s_{i}) \ -\ \pi _{j}( s_{j}) \ ||\ \geq \ 2r\ \}
```

Where r is the radius of a robot.

### Constructing the Diagram: The n-Dimension Problem

When n robot paths are considered, the coordination diagram that would represent the collusion set becomes an n-dimensional cube.  Therefore, an obstacle would be represented as a collection of points(s~1~, s~2~ , ... , s~n~) where at least two robots collide. Computation of multi-dimensional obstacles is costly and hard to implement. 

The n-dimensional space can instead be represented as a 2-D space by computing 2-D diagrams of each pair of robots. For *n* robots *n (n - 1) / 2* diagrams will be produced as shown in [4]. One such representation can be seen below where 5 robots occupy a coordination space.

## Coordination Planner

After the coordination diagram is drawn, the optimal coordination path needs to be determined. RRT, RRT*, and RRT*-connect algorithms were tested to find the solution. RRT*-connected gave a more optimal answer, and was faster.

## Supplementary Findings

### Unexpected Events

In the context of a warehouse, calculating the coordination path again at every change in the overall navigation would be inefficient as there can be constant changes in path-finding due to interruptions. In such a case, an incremental algorithm that makes changes "on the fly" can be more desirable. The algorithm in [5] aims to create such a system that can predict and avoid such interruptions.

## References

[1] Deadlock Free and Collision-free Coordination of Two Robot Manipulators

[2] Coordination of Multiple AGVs in an Industrial Application

[3] Online Plan Repair in Multi-robot Coordination with Disturbances

[4] Path Coordination for Multiple Mobile Robots: A Resolution-Complete Algorithm

[5] Coordination of Multiple AGVs in an Industrial Application
